# 6. Working with Modules
## 6.1 Module basics
- At this point in the course, I've shown you all of the TypeScript syntax that you'll need to know in order to use TypeScript successfully in your day to day development. In this chapter, I'm going to shift the focus to using the syntax you've already learned, but in a different way. And in fact, I'm going to start by going back to a JavaScript feature, modules.
- Put simply, JavaScript modules enable you to link code that is distributed across many files. Let me demonstrate. Here is an old school JavaScript web application stored in several files. And in our webpage, we use HTML script tags to download and load each of these files into the browser's memory. 
- As we do, the contents of each file get loaded into the same shared memory space. That means that when I define a function in one file and then define another function in another file with the same name, and then load both of these files like I'm doing here, the last function to be defined overwrites any others defined before it. With modules, however, each file shares its own memory space, so any function or variables that are defined within that module stay within that memory space and do not leak out, avoiding these kinds of collisions altogether. 
- What's more, modules can load from other modules. And since just about all modern browsers understand modules, they're even able to download these other modules on the fly based only on these kinds of references. This means that we no longer have to worry about loading every file of our application up front, but instead, let the browser load them for us as they're needed. 
- Now that I've shown modules in action, check out the next video, where I take a few steps back and show you how to write module-based code from scratch and how TypeScript can help you do it.

## 6.2 Defining global types with ambient modules.

- In the imports and exports video, I showed you how to convert an existing application that relied on global functions, to modules using imports and exports. However, if you have a large existing codebase that relies on global imports for existing JavaScript files that can't be converted, don't lose hope. 
- In this video, I'll show you how to document that JavaScript code, so you can continue to use those dependencies without a problem. To begin, I'll go back to the same application that I just converted, back to before I converted it. Remember this was the version of the application that was explicitly loading all of the JavaScript files. 
- I'll start out by converting the app.js file to TypeScript, just like last time, and I'll see that error again. TypeScript doesn't know about a function named formatDate, just like last time. However, in order to fix this problem this time, I'm going to create my own version of the TypeScript declaration files, I showed you way back in the first chapter. 
- As you might recall, these files have a d.ts extension. Since TypeScript is going to read the contents of this file, no matter what name I give it prior to the d.ts extension, I'll just call it globals.d.ts. Then I can create whatever type definitions I want in this file. In order to tell TypeScript that what I'm about to describe will be in the global namespace, I'll write the following. 
- This tells TypeScript that everything I write inside these braces, should be available in the global namespace. Notice the error here. This is TypeScript telling me that I can't use this syntax just anywhere, it has to be inside of a module. That means I need to export something in order for TypeScript to treat this as a module. So I'll just define an empty set of exports. 
- With that out of the way, I can now define whatever global definitions I like, for example, my function. Notice how I'm just writing the definition of the function and not the implementation of itself. And of course, this is TypeScript after all, so I can give it a parameter type and a return type. And while I'm at it, I can add some documentation too. 
- Once I'm all done with the definition, I can switch back to the TypeScript code that uses it, and see that not only has TypeScript found my definition just fine, but I even get the full documentation in IntelliSense as well. That's all I need to do in order to address this particular example, but rest assured that you can use any of the TypeScript concepts that I have shown in this course inside of these declaration files to describe any situation you may come across in your custom code. 
- It's also important to note that writing type declarations like this, doesn't actually ensure that the code is available at runtime. For example, if I were to forget to include the script tag that loads the util.js file into my browser, my TypeScript code would continue to compile without any errors, only to crash at runtime, when it goes to execute a function that doesn't exist. Regardless of that caveat, having this ability to define types for JavaScript code, that lives outside of your TypeScript files, is a great way to get full TypeScript support when integrating with existing JavaScript codebases.

    ```ts
    declare global {
        /** this formats a date value to a human-readable format */
        function formatDate(date: Date): String
    }

    export {}
    ```
## 6.3 Declaration merging

## 6.4 Executing modular code